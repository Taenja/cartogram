Fbij <- mass[j] * (distance / radius[j]) ^ 2 * (4 - 3 * (distance / radius[j]))
Fij[distance <= radius[j]] <- Fbij[distance <= radius[j]]
Fij <- Fij * forceReductionFactor / distance
# calculate new border coordinates
newpts <- newpts + cbind(X1 = Fij, X2 = Fij) * (newpts - centroids[rep(j, nrow(newpts)), ])
}
# save final coordinates from this iteration to coordinate list
if (sf::st_geometry_type(sf::st_geometry(x.iter)[[i]]) == "POLYGON"){
sf::st_geometry(x.iter)[[i]][[idx[k, "L1"]]] <- newpts
} else {
sf::st_geometry(x.iter)[[i]][[idx[k, "L2"]]][[idx[k, "L1"]]] <- newpts
}
}
}
}
# return and try to fix self-intersections
return(sf::st_buffer(x.iter, 0))
}
us_cont <- my_cartogram(x = usa_sf("laea"),weight =  "pop_2014")
setwd("/home/csaybar/Documents/Github/cartogram/")
world_ss <- st_read("data/world_slope.geojson")
library(sf)
world_ss <- st_read("data/world_slope.geojson")
library(sf)
world_ss <- st_read("data/sen_slope.json")
world_ss
world_ss
library(sf)
world_ss <- st_read("data/sen_slope.json")
vector_example <- st_read("data/sen_slope.json")
value <- vector_example[["sen_slope"]]
value
global_sf <- st_read("data/sen_slope.json")
global_sf_sen <- vector_example["sen_slope"]
global_sf_sen
global_sf_sen <- vector_example["sen_slope"]
global_sf_sen <- vector_example["sen_slope"]
plot(global_sf_sen)
global_sf_sen
value <- global_sf_sen[["sen_slope"]]
value
# 2. sum up total value
valueTotal <- sum(value, na.rm = TRUE)
library(sf)
# 1. Prepare data
x <- st_read("data/sen_slope.json")
# 1. Prepare data
x <- st_read("data/sen_slope.json")
weight <- "sen_slope"
value <- x[[weight]]
value
x[weight]
plot(x[weight])
# 2. sum up total value
valueTotal <- sum(value, na.rm = TRUE)
meanSizeError <- 100
x.iter <- x
x.iter
# 3. iterate until itermax is reached
z <- 1
x.iter_geom <- sf::st_geometry(x.iter)
x.iter_geom
centroids_sf <- sf::st_centroid(x.iter_geom)
centroids_sf
st_crs(centroids_sf) <- sf::st_crs(NULL)
centroids <- do.call(rbind, centroids_sf)
centroids
centroids_sf
plot(centroids_sf)
# 3.1 area for polygons and total area
area <- as.numeric(sf::st_area(x.iter))
area
areaTotal <- as.numeric(sum(area))
area[area < 0] <- 0
area
areaTotal
areaTotal * value
areaTotal * value / valueTotal
# 3.2 prepare force field calculations
desired <- areaTotal * value / valueTotal
# 3.2 prepare force field calculations
desired <- areaTotal * value / valueTotal
desired[desired == 0] <- 0.01 # set minimum size to prevent inf values size Error
radius <- sqrt(area / pi)
radius
mass <- sqrt(desired / pi) - sqrt(area / pi)
mass
sizeError <- apply(cbind(area, desired), 1, max) / apply(cbind(area, desired), 1, min)
meanSizeError <- mean(sizeError, na.rm = TRUE)
forceReductionFactor <- 1 / (1 + meanSizeError)
forceReductionFactor
message(paste0("Mean size error for iteration ", z , ": ", meanSizeError))
# 3.2 prepare force field calculations
desired <- areaTotal * value / valueTotal
desired[desired == 0] <- 0.01 # set minimum size to prevent inf values size Error
radius <- sqrt(area / pi)
mass <- sqrt(desired / pi) - sqrt(area / pi)
mass
desired
radius <- sqrt(area / pi)
mass <- sqrt(desired / pi) - sqrt(area / pi)
sizeError <- apply(cbind(area, desired), 1, max) / apply(cbind(area, desired), 1, min)
meanSizeError <- mean(sizeError, na.rm = TRUE)
forceReductionFactor <- 1 / (1 + meanSizeError)
forceReductionFactor
radius
sizeError <- apply(cbind(area, desired), 1, max) / apply(cbind(area, desired), 1, min)
sizeError
meanSizeError <- mean(sizeError, na.rm = TRUE)
meanSizeError
forceReductionFactor <- 1 / (1 + meanSizeError)
# 3.3 Estimate the error
sizeError <- apply(cbind(area, desired), 1, max) / apply(cbind(area, desired), 1, min)
meanSizeError <- mean(sizeError, na.rm = TRUE)
forceReductionFactor <- 1 / (1 + meanSizeError)
message(paste0("Mean size error for iteration ", z , ": ", meanSizeError))
# 3.4 Estimate the error
i <- 1
pts <- sf::st_coordinates(x.iter_geom[[i]])
idx <- unique(pts[, colnames(pts) %in% c("L1", "L2", "L3")])
for (k in seq_len(nrow(idx))) {
newpts <- pts[pts[, "L1"] == idx[k, "L1"] & pts[, "L2"] == idx[k, "L2"], c("X", "Y")]
distances <- apply(centroids, 1, function(pt) {
ptm <- matrix(pt, nrow=nrow(newpts), ncol=2, byrow=T)
sqrt(rowSums((newpts - ptm)^2))
})
#dold <- spDists(newpts, centroids)
#all.equal(distances, dold)
#distance
for (j in  seq_len(nrow(centroids))) {
distance <- distances[, j]
# calculate force vector
Fij <- mass[j] * radius[j] / distance
Fbij <- mass[j] * (distance / radius[j]) ^ 2 * (4 - 3 * (distance / radius[j]))
Fij[distance <= radius[j]] <- Fbij[distance <= radius[j]]
Fij <- Fij * forceReductionFactor / distance
# calculate new border coordinates
newpts <- newpts + cbind(X1 = Fij, X2 = Fij) * (newpts - centroids[rep(j, nrow(newpts)), ])
}
# save final coordinates from this iteration to coordinate list
if (sf::st_geometry_type(sf::st_geometry(x.iter)[[i]]) == "POLYGON"){
sf::st_geometry(x.iter)[[i]][[idx[k, "L1"]]] <- newpts
} else {
sf::st_geometry(x.iter)[[i]][[idx[k, "L2"]]][[idx[k, "L1"]]] <- newpts
}
}
seq_len(nrow(x.iter))
pts <- sf::st_coordinates(x.iter_geom[[i]])
idx <- unique(pts[, colnames(pts) %in% c("L1", "L2", "L3")])
idx
pts
seq_len(nrow(idx))
newpts <- pts[pts[, "L1"] == idx[k, "L1"] & pts[, "L2"] == idx[k, "L2"], c("X", "Y")]
newpts
distances <- apply(centroids, 1, function(pt) {
ptm <- matrix(pt, nrow=nrow(newpts), ncol=2, byrow=T)
sqrt(rowSums((newpts - ptm)^2))
})
distances
#distance
for (j in  seq_len(nrow(centroids))) {
distance <- distances[, j]
# calculate force vector
Fij <- mass[j] * radius[j] / distance
Fbij <- mass[j] * (distance / radius[j]) ^ 2 * (4 - 3 * (distance / radius[j]))
Fij[distance <= radius[j]] <- Fbij[distance <= radius[j]]
Fij <- Fij * forceReductionFactor / distance
# calculate new border coordinates
newpts <- newpts + cbind(X1 = Fij, X2 = Fij) * (newpts - centroids[rep(j, nrow(newpts)), ])
}
newpts
sf::st_geometry(x.iter)[[i]][[idx[k, "L1"]]] <- newpts
pts <- sf::st_coordinates(x.iter_geom[[i]])
pts
x.iter_geom
x.iter_geom[[i]]
pts <- sf::st_coordinates(x.iter_geom[[i]])
pts <- sf::st_coordinates(x.iter_geom[[i]])
idx <- unique(pts[, colnames(pts) %in% c("L1", "L2", "L3")])
idx
pts
newpts <- pts[pts[, "L1"] == idx[k, "L1"] & pts[, "L2"] == idx[k, "L2"], c("X", "Y")]
newpts
distances <- apply(centroids, 1, function(pt) {
ptm <- matrix(pt, nrow=nrow(newpts), ncol=2, byrow=T)
sqrt(rowSums((newpts - ptm)^2))
})
distances
ptm <- matrix(pt, nrow=nrow(newpts), ncol=2, byrow=T)
distances <- apply(centroids, 1, function(pt) {
ptm <- matrix(pt, nrow=nrow(newpts), ncol=2, byrow=T)
sqrt(rowSums((newpts - ptm)^2))
})
distances
distances <- apply(centroids, 1, function(pt) {
ptm <- matrix(pt, nrow=nrow(newpts), ncol=2, byrow=T)
sqrt(rowSums((newpts - ptm)^2))
})
seq_len(nrow(x.iter))
# 2. sum up total value
valueTotal <- sum(value, na.rm = TRUE)
meanSizeError <- 100
x.iter <- x
# 3. iterate until itermax is reached
z <- 1
x.iter_geom <- sf::st_geometry(x.iter)
centroids_sf <- sf::st_centroid(x.iter_geom)
st_crs(centroids_sf) <- sf::st_crs(NULL)
centroids <- do.call(rbind, centroids_sf)
plot(centroids_sf)
# 3.1 area for polygons and total area
area <- as.numeric(sf::st_area(x.iter))
areaTotal <- as.numeric(sum(area))
area[area < 0] <- 0
# 3.2 prepare force field calculations
desired <- areaTotal * value / valueTotal
desired[desired == 0] <- 0.01 # set minimum size to prevent inf values size Error
radius <- sqrt(area / pi)
mass <- sqrt(desired / pi) - sqrt(area / pi)
# 3.3 Estimate the error
sizeError <- apply(cbind(area, desired), 1, max) / apply(cbind(area, desired), 1, min)
meanSizeError <- mean(sizeError, na.rm = TRUE)
forceReductionFactor <- 1 / (1 + meanSizeError)
message(paste0("Mean size error for iteration ", z , ": ", meanSizeError))
seq_len(nrow(x.iter))
seq_len(nrow(x.iter))
seq_len(nrow(x.iter))
seq_len(nrow(idx))
# 3.4 Estimate the error
pts <- sf::st_coordinates(x.iter_geom[[i]])
idx <- unique(pts[, colnames(pts) %in% c("L1", "L2", "L3")])
# 3.4 Estimate the error
pts <- sf::st_coordinates(x.iter_geom[[i]])
idx <- unique(pts[, colnames(pts) %in% c("L1", "L2", "L3")])
newpts <- pts[pts[, "L1"] == idx[k, "L1"] & pts[, "L2"] == idx[k, "L2"], c("X", "Y")]
distances <- apply(centroids, 1, function(pt) {
ptm <- matrix(pt, nrow=nrow(newpts), ncol=2, byrow=T)
sqrt(rowSums((newpts - ptm)^2))
})
distances
newpts
# 3.4 Estimate the error
pts <- sf::st_coordinates(x.iter_geom[[i]])
pts
# 3.4 Estimate the error
i <- 1
pts <- sf::st_coordinates(x.iter_geom[[i]])
pts
x.iter_geom
x.iter_geom[i]
plot(x.iter_geom[i])
# 3.4 Estimate the error
i <- 1
plot(x.iter_geom[i])
# 3.5
pts <- sf::st_coordinates(x.iter_geom[[i]])
idx <- unique(pts[, colnames(pts) %in% c("L1", "L2", "L3")])
newpts <- pts[pts[, "L1"] == idx[k, "L1"] & pts[, "L2"] == idx[k, "L2"], c("X", "Y")]
distances <- apply(centroids, 1, function(pt) {
ptm <- matrix(pt, nrow=nrow(newpts), ncol=2, byrow=T)
sqrt(rowSums((newpts - ptm)^2))
})
distances
pts
idx <- unique(pts[, colnames(pts) %in% c("L1", "L2", "L3")])
newpts <- pts[pts[, "L1"] == idx[k, "L1"] & pts[, "L2"] == idx[k, "L2"], c("X", "Y")]
newpts
distances <- apply(centroids, 1, function(pt) {
ptm <- matrix(pt, nrow=nrow(newpts), ncol=2, byrow=T)
sqrt(rowSums((newpts - ptm)^2))
})
distances
dim(distances)
distances <- apply(centroids, 1, function(pt) {
ptm <- matrix(pt, nrow=nrow(newpts), ncol=2, byrow=T)
sqrt(rowSums((newpts - ptm)^2))
})
distances
newpts <- pts[pts[, "L1"] == idx[k, "L1"] & pts[, "L2"] == idx[k, "L2"], c("X", "Y")]
newpts
plot(newpts)
# 3.5 Distance
pts <- sf::st_coordinates(x.iter_geom[[i]])
idx <- unique(pts[, colnames(pts) %in% c("L1", "L2", "L3")])
newpts <- pts[pts[, "L1"] == idx[k, "L1"] & pts[, "L2"] == idx[k, "L2"], c("X", "Y")]
distances <- apply(centroids, 1, function(pt) {
ptm <- matrix(pt, nrow=nrow(newpts), ncol=2, byrow=T)
sqrt(rowSums((newpts - ptm)^2))
})
for (j in  seq_len(nrow(centroids))) {
distance <- distances[, j]
# calculate force vector
Fij <- mass[j] * radius[j] / distance
Fbij <- mass[j] * (distance / radius[j]) ^ 2 * (4 - 3 * (distance / radius[j]))
Fij[distance <= radius[j]] <- Fbij[distance <= radius[j]]
Fij <- Fij * forceReductionFactor / distance
# calculate new border coordinates
newpts_01 <- newpts + cbind(X1 = Fij, X2 = Fij) * (newpts - centroids[rep(j, nrow(newpts)), ])
}
plot(newpts_01)
plot(newpts)
plot(newpts_01)
Fij
plot(newpts)
plot(newpts_01, col = "red")
plot(newpts)
plot(newpts)
points(newpts_01, col = "red")
# 3.5 Distance
pts <- sf::st_coordinates(x.iter_geom[[i]])
idx <- unique(pts[, colnames(pts) %in% c("L1", "L2", "L3")])
idx
pts
newpts <- pts[pts[, "L1"] == idx[k, "L1"] & pts[, "L2"] == idx[k, "L2"], c("X", "Y")]
newpts
library(sf)
# 1. Prepare data
x <- st_read("data/sen_slope.json")
weight <- "sen_slope"
value <- x[[weight]]
plot(x[weight])
# 2. sum up total value
valueTotal <- sum(value, na.rm = TRUE)
meanSizeError <- 100
x.iter <- x
# 3. iterate until itermax is reached
z <- 1
x.iter_geom <- sf::st_geometry(x.iter)
centroids_sf <- sf::st_centroid(x.iter_geom)
st_crs(centroids_sf) <- sf::st_crs(NULL)
centroids <- do.call(rbind, centroids_sf)
plot(centroids_sf)
# 3.1 area for polygons and total area
area <- as.numeric(sf::st_area(x.iter))
areaTotal <- as.numeric(sum(area))
area[area < 0] <- 0
# 3.2 prepare force field calculations
desired <- areaTotal * value / valueTotal
desired[desired == 0] <- 0.01 # set minimum size to prevent inf values size Error
radius <- sqrt(area / pi)
mass <- sqrt(desired / pi) - sqrt(area / pi)
mass
radius
# 3.3 Estimate the error
sizeError <- apply(cbind(area, desired), 1, max) / apply(cbind(area, desired), 1, min)
meanSizeError <- mean(sizeError, na.rm = TRUE)
forceReductionFactor <- 1 / (1 + meanSizeError)
message(paste0("Mean size error for iteration ", z , ": ", meanSizeError))
# 3.4 Estimate the error
i <- 1
plot(x.iter_geom[i])
# 3.5 Distance
pts <- sf::st_coordinates(x.iter_geom[[i]])
idx <- unique(pts[, colnames(pts) %in% c("L1", "L2", "L3")])
newpts <- pts[pts[, "L1"] == idx[k, "L1"] & pts[, "L2"] == idx[k, "L2"], c("X", "Y")]
distances <- apply(centroids, 1, function(pt) {
ptm <- matrix(pt, nrow=nrow(newpts), ncol=2, byrow=T)
sqrt(rowSums((newpts - ptm)^2))
})
distances
for (j in  seq_len(nrow(centroids))) {
distance <- distances[, j]
# calculate force vector
Fij <- mass[j] * radius[j] / distance
Fbij <- mass[j] * (distance / radius[j]) ^ 2 * (4 - 3 * (distance / radius[j]))
Fij[distance <= radius[j]] <- Fbij[distance <= radius[j]]
Fij <- Fij * forceReductionFactor / distance
# calculate new border coordinates
newpts_01 <- newpts + cbind(X1 = Fij, X2 = Fij) * (newpts - centroids[rep(j, nrow(newpts)), ])
}
plot(newpts)
points(newpts_01, col = "red")
for (i in 1:10) {
# 3.5 Distance
pts <- sf::st_coordinates(x.iter_geom[[i]])
idx <- unique(pts[, colnames(pts) %in% c("L1", "L2", "L3")])
newpts <- pts[pts[, "L1"] == idx[k, "L1"] & pts[, "L2"] == idx[k, "L2"], c("X", "Y")]
distances <- apply(centroids, 1, function(pt) {
ptm <- matrix(pt, nrow=nrow(newpts), ncol=2, byrow=T)
sqrt(rowSums((newpts - ptm)^2))
})
for (j in  seq_len(nrow(centroids))) {
distance <- distances[, j]
# calculate force vector
Fij <- mass[j] * radius[j] / distance
Fbij <- mass[j] * (distance / radius[j]) ^ 2 * (4 - 3 * (distance / radius[j]))
Fij[distance <= radius[j]] <- Fbij[distance <= radius[j]]
Fij <- Fij * forceReductionFactor / distance
# calculate new border coordinates
newpts_01 <- newpts + cbind(X1 = Fij, X2 = Fij) * (newpts - centroids[rep(j, nrow(newpts)), ])
}
plot(newpts)
points(newpts_01, col = "red")
}
for (i in 1:10) {
# 3.5 Distance
pts <- sf::st_coordinates(x.iter_geom[[i]])
idx <- unique(pts[, colnames(pts) %in% c("L1", "L2", "L3")])
newpts <- pts[pts[, "L1"] == idx[k, "L1"] & pts[, "L2"] == idx[k, "L2"], c("X", "Y")]
distances <- apply(centroids, 1, function(pt) {
ptm <- matrix(pt, nrow=nrow(newpts), ncol=2, byrow=T)
sqrt(rowSums((newpts - ptm)^2))
})
for (j in  seq_len(nrow(centroids))) {
distance <- distances[, j]
# calculate force vector
Fij <- mass[j] * radius[j] / distance
Fbij <- mass[j] * (distance / radius[j]) ^ 2 * (4 - 3 * (distance / radius[j]))
Fij[distance <= radius[j]] <- Fbij[distance <= radius[j]]
Fij <- Fij * forceReductionFactor / distance
# calculate new border coordinates
newpts_01 <- newpts + cbind(X1 = Fij, X2 = Fij) * (newpts - centroids[rep(j, nrow(newpts)), ])
}
plot(newpts)
points(newpts_01, col = "red")
}
# 3.4 Estimate the error
i <- 1
plot(x.iter_geom[i])
# 3.5 Distance
pts <- sf::st_coordinates(x.iter_geom[[i]])
idx <- unique(pts[, colnames(pts) %in% c("L1", "L2", "L3")])
newpts <- pts[pts[, "L1"] == idx[k, "L1"] & pts[, "L2"] == idx[k, "L2"], c("X", "Y")]
distances <- apply(centroids, 1, function(pt) {
ptm <- matrix(pt, nrow=nrow(newpts), ncol=2, byrow=T)
sqrt(rowSums((newpts - ptm)^2))
})
for (j in  seq_len(nrow(centroids))) {
distance <- distances[, j]
# calculate force vector
Fij <- mass[j] * radius[j] / distance
Fbij <- mass[j] * (distance / radius[j]) ^ 2 * (4 - 3 * (distance / radius[j]))
Fij[distance <= radius[j]] <- Fbij[distance <= radius[j]]
Fij <- Fij * forceReductionFactor / distance
# calculate new border coordinates
newpts_01 <- newpts + cbind(X1 = Fij, X2 = Fij) * (newpts - centroids[rep(j, nrow(newpts)), ])
}
plot(newpts)
newpts <- pts[pts[, "L1"] == idx[k, "L1"] & pts[, "L2"] == idx[k, "L2"], c("X", "Y")]
distances <- apply(centroids, 1, function(pt) {
ptm <- matrix(pt, nrow=nrow(newpts), ncol=2, byrow=T)
sqrt(rowSums((newpts - ptm)^2))
})
for (j in  seq_len(nrow(centroids))) {
distance <- distances[, j]
# calculate force vector
Fij <- mass[j] * radius[j] / distance
Fbij <- mass[j] * (distance / radius[j]) ^ 2 * (4 - 3 * (distance / radius[j]))
Fij[distance <= radius[j]] <- Fbij[distance <= radius[j]]
Fij <- Fij * forceReductionFactor / distance
# calculate new border coordinates
newpts_01 <- newpts + cbind(X1 = Fij, X2 = Fij) * (newpts - centroids[rep(j, nrow(newpts)), ])
}
Fij
Fij * forceReductionFactor / distance
forceReductionFactor
Fij <- Fij * 10 / distance
# 3.5 Distance
pts <- sf::st_coordinates(x.iter_geom[[i]])
idx <- unique(pts[, colnames(pts) %in% c("L1", "L2", "L3")])
newpts <- pts[pts[, "L1"] == idx[k, "L1"] & pts[, "L2"] == idx[k, "L2"], c("X", "Y")]
distances <- apply(centroids, 1, function(pt) {
ptm <- matrix(pt, nrow=nrow(newpts), ncol=2, byrow=T)
sqrt(rowSums((newpts - ptm)^2))
})
for (j in  seq_len(nrow(centroids))) {
distance <- distances[, j]
# calculate force vector
Fij <- mass[j] * radius[j] / distance
Fbij <- mass[j] * (distance / radius[j]) ^ 2 * (4 - 3 * (distance / radius[j]))
Fij[distance <= radius[j]] <- Fbij[distance <= radius[j]]
Fij <- Fij * 10 / distance
# calculate new border coordinates
newpts_01 <- newpts + cbind(X1 = Fij, X2 = Fij) * (newpts - centroids[rep(j, nrow(newpts)), ])
}
plot(newpts)
points(newpts_01, col = "red")
Fij <- Fij * forceReductionFactor*10 / distance
idx <- unique(pts[, colnames(pts) %in% c("L1", "L2", "L3")])
newpts <- pts[pts[, "L1"] == idx[k, "L1"] & pts[, "L2"] == idx[k, "L2"], c("X", "Y")]
distances <- apply(centroids, 1, function(pt) {
ptm <- matrix(pt, nrow=nrow(newpts), ncol=2, byrow=T)
sqrt(rowSums((newpts - ptm)^2))
})
for (j in  seq_len(nrow(centroids))) {
distance <- distances[, j]
# calculate force vector
Fij <- mass[j] * radius[j] / distance
Fbij <- mass[j] * (distance / radius[j]) ^ 2 * (4 - 3 * (distance / radius[j]))
Fij[distance <= radius[j]] <- Fbij[distance <= radius[j]]
Fij <- Fij * forceReductionFactor*10 / distance
# calculate new border coordinates
newpts_01 <- newpts + cbind(X1 = Fij, X2 = Fij) * (newpts - centroids[rep(j, nrow(newpts)), ])
}
plot(newpts)
points(newpts_01, col = "red")
distances <- apply(centroids, 1, function(pt) {
ptm <- matrix(pt, nrow=nrow(newpts), ncol=2, byrow=T)
sqrt(rowSums((newpts - ptm)^2))
})
for (j in  seq_len(nrow(centroids))) {
distance <- distances[, j]
# calculate force vector
Fij <- mass[j] * radius[j] / distance
Fbij <- mass[j] * (distance / radius[j]) ^ 2 * (4 - 3 * (distance / radius[j]))
Fij[distance <= radius[j]] <- Fbij[distance <= radius[j]]
Fij <- Fij * forceReductionFactor*100 / distance
# calculate new border coordinates
newpts_01 <- newpts + cbind(X1 = Fij, X2 = Fij) * (newpts - centroids[rep(j, nrow(newpts)), ])
}
plot(newpts)
points(newpts_01, col = "red")
